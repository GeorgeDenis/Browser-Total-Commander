<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>main API documentation</title>
<meta name="description" content="Browser Total Commander Module â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>main</code></h1>
</header>
<section id="section-intro">
<p>Browser Total Commander Module.</p>
<p>This module provides a web application that mimics the functionality of Total Commander,
a file manager with capabilities for file browsing, organizing, and editing. It allows users
to perform various file operations copy, delete, move, rename, create files, create folders, edit text files and view
content within a browser interface. The module is designed to offer a similar experience to Total Commander users with
additional web-base benefits.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Browser Total Commander Module.

This module provides a web application that mimics the functionality of Total Commander,
a file manager with capabilities for file browsing, organizing, and editing. It allows users
to perform various file operations copy, delete, move, rename, create files, create folders, edit text files and view
content within a browser interface. The module is designed to offer a similar experience to Total Commander users with
additional web-base benefits.
&#34;&#34;&#34;
from flask import Flask, jsonify, request, render_template
import datetime
import os
import shutil
import psutil

app = Flask(__name__)


@app.route(&#39;/partitions&#39;, methods=[&#39;GET&#39;])
def get_partition():
    &#34;&#34;&#34;
    Get a list of disk partitions.

    Retrieves the mounted disk partitions using the psutil library and returns them
    as a JSON response. Each partition is represented by its device name.

    Returns:
        A JSON object with a &#39;partitions&#39; key containing a list of partitions.
        On error, returns a JSON object with an &#39;error&#39; key and status code 500.
    &#34;&#34;&#34;
    partitions = []
    try:
        for partition in psutil.disk_partitions():
            partitions.append(partition.device[0])
    except Exception as e:
        return jsonify(error=str(e)), 500

    return jsonify({&#39;partitions&#39;: partitions}), 200


@app.route(&#39;/folder/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def create_folder(partition):
    &#34;&#34;&#34;
    Create a folder in the specified partition and path.

    This function creates a folder in the given partition with the path provided
    via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
    to the root of the specified partition.

    Args:
        partition: A string indicating the partition on which to create the folder.

    Returns:
        A JSON response indicating success or failure. On success, returns a message
        indicating the folder was created. On failure, returns an error message with details.
    &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    folder_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    if not path or not isinstance(path, str):
        return jsonify({&#39;error&#39;: &#39;Invalid path provided&#39;}), 400

    if os.path.isdir(folder_path):
        return jsonify({&#39;error&#39;: &#39;The folder already exists&#39;})

    try:
        os.mkdir(folder_path)
        return jsonify({&#39;message&#39;: &#39;Folder created successfully&#39;})
    except PermissionError:
        return jsonify({&#39;error&#39;: &#39;Permission denied&#39;}), 403
    except FileNotFoundError:
        return jsonify({&#39;error&#39;: &#39;Invalid partition or path&#39;}), 400
    except OSError as oe:
        return jsonify({&#39;error&#39;: f&#34;OS error: {str(oe)}&#34;}), 400
    except Exception as e:  # Catch any other unexpected errors
        return jsonify({&#34;error&#34;: f&#34;Unexpected error occurred: {e}&#34;}), 500


@app.route(&#39;/file/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def create_file(partition):
    &#34;&#34;&#34;Create a file in the specified partition and path.

        This function creates a file in the given partition with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition.

        Args:
            partition: A string indicating the partition on which to create the file.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file was created. On failure, returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    file_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;

    if not path or not isinstance(path, str):
        return jsonify({&#39;error&#39;: &#39;Invalid path provided&#39;}), 400

    if os.path.isfile(file_path):
        return jsonify({&#39;error&#39;: &#39;The file already exists&#39;})
    try:
        with open(file_path, &#39;x&#39;) as file:
            pass
        return jsonify({&#39;message&#39;: f&#39;File created at {file_path}&#39;}), 201
    except PermissionError:
        return jsonify({&#39;error&#39;: &#39;Permission denied&#39;}), 403
    except FileNotFoundError:
        return jsonify({&#39;error&#39;: &#39;Invalid partition or path&#39;}), 400
    except OSError as oe:
        return jsonify({&#39;error&#39;: f&#34;OS error: {str(oe)}&#34;}), 400
    except Exception as e:
        return jsonify({&#39;error&#39;: str(e)}), 500


@app.route(&#39;/&lt;partition&gt;&#39;, methods=[&#39;GET&#39;])
def show_partition(partition):
    &#34;&#34;&#34;Returns the files and directories structure from the specified partition and path.

        This function returns the files and directories structure in the given partition with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition.

        Args:
            partition: A string indicating the partition on which to create the file.

        Returns:
            A JSON response indicating success or failure. On success, returns the files from the specified partition
            and path along some properties like path, extension, size, the date when the file was created. On failure,
            returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    files = {}
    exclusions = {&#39;$RECYCLE.BIN&#39;, &#39;$Recycle.Bin&#39;, &#39;.GamingRoot&#39;, &#39;System Volume Information&#39;}

    try:
        for name in os.listdir(base_path):
            if name in exclusions:
                continue
            path = os.path.join(base_path, name)
            file_stats = os.stat(path)
            extension = os.path.splitext(name)[1]
            size = 0 if os.path.isdir(path) else file_stats.st_size
            date = datetime.datetime.fromtimestamp(file_stats.st_ctime).strftime(&#39;%Y-%m-%d %H:%M&#39;)
            files[name] = {&#39;path&#39;: path, &#39;extension&#39;: extension, &#39;size&#39;: size, &#39;date&#39;: date}
    except Exception as e:
        return jsonify({&#34;error&#34;: f&#34;Could not access partition {partition}: {e}&#34;}), 500

    return jsonify({&#34;folders&#34;: files}), 200


@app.route(&#39;/&#39;, methods=[&#39;DELETE&#39;])
def delete_items():
    &#34;&#34;&#34;
        Delete files and directories from the specified paths.

        This function attempts to delete files and directories specified in the &#39;paths&#39; JSON array from the request
        body.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file or the files were deleted. On failure, returns an error message with details.
        &#34;&#34;&#34;
    paths = request.json.get(&#39;paths&#39;, [])
    results = []
    for path in paths:
        try:
            if not os.path.exists(path):
                results.append({&#34;path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;Path {path} does not exist&#34;})
                continue
            shutil.rmtree(path) if os.path.isdir(path) else os.remove(path)
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Success&#34;})
        except PermissionError:
            results.append({&#34;path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;Could not delete element {path}: {e}&#34;})
    return jsonify({&#34;message&#34;: &#34;All elements have been successfully deleted&#34;, &#34;results&#34;: results})


@app.route(&#39;/copy/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def copy_items(partition):
    &#34;&#34;&#34;Copy items from the given paths to the specified partition and path.

        This function attempts to copy files and directories specified in the &#39;paths&#39;
        JSON array from the request body to the target partition and path with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition. It returns a summary of the copy operations, including successes
        and failures.

        Args:
            partition: A string indicating the target partition for the copy operation.

        Returns:
            A JSON object summarizing the results of the copy operations, including
            paths attempted, status of each, and any failure reasons.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;

    paths = request.json.get(&#39;paths&#39;, [])
    results = []

    for src_path in paths:
        try:
            filename = os.path.basename(src_path)
            dest_path = os.path.join(base_path, filename)
            if os.path.exists(dest_path):
                results.append({&#34;src_path&#34;: src_path, &#34;dest_path&#34;: dest_path, &#34;status&#34;: &#34;Failed&#34;,
                                &#34;reason&#34;: &#34;Destination file already exists&#34;})
                continue
            if os.path.isdir(src_path):
                shutil.copytree(src_path, dest_path)
            elif os.path.isfile(src_path):
                shutil.copy(src_path, dest_path)
            else:
                results.append(
                    {&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Source is not a valid file or directory&#34;})
                continue
            results.append({&#34;src_path&#34;: src_path, &#34;dest_path&#34;: dest_path, &#34;status&#34;: &#34;Success&#34;})
        except PermissionError:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: str(e)})
    return jsonify({&#34;message&#34;: &#34;Copy operation completed&#34;, &#34;results&#34;: results})


@app.route(&#39;/move/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def move_items(partition):
    &#34;&#34;&#34;Move items from the given paths to the specified partition and path.

        This function attempts to move files and directories specified in the &#39;paths&#39;
        JSON array from the request body to the target partition and path. It returns
        a summary of the move operations, including successes and failures.

        Args:
            partition: A string indicating the target partition for the move operation.

        Returns:
            A JSON object summarizing the results of the move operations, including
            paths attempted, status of each, and any failure reasons.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    paths = request.json.get(&#39;paths&#39;, [])
    results = []
    for src_path in paths:
        try:
            item_name = os.path.basename(src_path)
            dest_path = os.path.join(base_path, item_name)
            if os.path.exists(dest_path):
                results.append({
                    &#34;src_path&#34;: src_path,
                    &#34;dest_path&#34;: dest_path,
                    &#34;status&#34;: &#34;Failed&#34;,
                    &#34;reason&#34;: &#34;Destination file or directory already exists&#34;
                })
                continue
            shutil.move(src_path, dest_path)

            results.append({
                &#34;src_path&#34;: src_path,
                &#34;dest_path&#34;: dest_path,
                &#34;status&#34;: &#34;Success&#34;
            })
        except PermissionError:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({
                &#34;src_path&#34;: src_path,
                &#34;status&#34;: &#34;Failed&#34;,
                &#34;reason&#34;: str(e)
            })
    return jsonify({
        &#34;message&#34;: &#34;Move operation completed&#34;,
        &#34;results&#34;: results
    })


@app.route(&#39;/rename&#39;, methods=[&#39;POST&#39;])
def rename_data():
    &#34;&#34;&#34;Rename a file or a folder from the specified source name with the specified destination name.

        This function renames a file or a folder name from the specified source with the destination name,
        both source name and destination name are taken from the request body.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file or folder was renamed with the provided name. On failure,
            returns an error message with details.
        &#34;&#34;&#34;
    data = request.json
    source = data.get(&#39;src&#39;, None)
    destination = data.get(&#39;dest&#39;, None)
    if not source or not destination:
        return jsonify({&#34;error&#34;: &#34;Source and destination must be provided&#34;}), 400
    try:
        if not os.path.exists(source):
            return jsonify({&#34;error&#34;: &#34;Source file or directory does not exist&#34;}), 404
        if os.path.exists(destination):
            return jsonify({&#34;error&#34;: &#34;Destination file or directory already exists&#34;}), 400
        os.rename(source, destination)
        return jsonify({&#34;message&#34;: f&#34;Successfully renamed {source} to {destination}&#34;})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except OSError as oe:
        return jsonify({&#34;error&#34;: f&#34;OS error: {str(oe)}&#34;}), 500
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500


@app.route(&#39;/textfile/&lt;partition&gt;&#39;, methods=[&#39;GET&#39;])
def get_textfile(partition):
    &#34;&#34;&#34;Get a text file content from the specified partition and path.

        This function takes a text file content from the specified partition and path with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it returns an error message.

        Args:
            partition: A string indicating the partition on which to get the text content.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file was edited. On failure, returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    if not path:
        return jsonify({&#34;error&#34;: &#34;Path is required&#34;}), 400
    base_path = f&#34;{partition}://{path}&#34;
    try:
        if not os.path.isfile(base_path):
            return jsonify({&#34;error&#34;: &#34;File does not exist or is not a file&#34;}), 404
        with open(base_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            content = f.read()
        return jsonify({&#34;text&#34;: content})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except IOError as e:
        return jsonify({&#34;error&#34;: f&#34;Could not read file: {e}&#34;}), 500
    except OSError as oe:
        return jsonify({&#34;error&#34;: f&#34;OS error: {str(oe)}&#34;}), 500
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500


@app.route(&#39;/textfile/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def edit_textfile(partition):
    &#34;&#34;&#34;Edit a text file from the specified partition and path.

    This function edits a file from the specified partition and path with the path provided
    via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it returns an error message.

    Args:
        partition: A string indicating the partition on which to edit the file.

    Returns:
        A JSON response indicating success or failure. On success, returns a message
        indicating the file was edited. On failure, returns an error message with details.
    &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    data = request.json
    text = data.get(&#39;text&#39;, None)
    if not path:
        return jsonify({&#34;error&#34;: &#34;Path is required&#34;}), 400
    base_path = f&#34;{partition}://{path}&#34;
    try:
        if not os.path.isfile(base_path):
            return jsonify({&#34;error&#34;: &#34;File does not exist or is not a file&#34;}), 404
        with open(base_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            content = f.write(text)
        return jsonify({&#34;message&#34;: f&#34;Successfully edited {path}&#34;})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except IOError as e:
        return jsonify({&#34;error&#34;: f&#34;Could not edit file: {e}&#34;}), 500
    except UnicodeEncodeError as e:
        return jsonify({&#34;error&#34;: f&#34;Encoding error with provided text: {e}&#34;}), 400
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500


@app.route(&#39;/&#39;)
def file_manager():
    &#34;&#34;&#34;
    The function is used to generate output from a template file based on the Jinja2 engine that is found in the
    application&#39;s templates folder
    Returns:
        An HTML template as a response
    &#34;&#34;&#34;
    return render_template(&#39;file_manager.html&#39;)


if __name__ == &#39;__main__&#39;:
    app.run(debug=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="main.copy_items"><code class="name flex">
<span>def <span class="ident">copy_items</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy items from the given paths to the specified partition and path.</p>
<p>This function attempts to copy files and directories specified in the 'paths'
JSON array from the request body to the target partition and path with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it defaults
to the root of the specified partition. It returns a summary of the copy operations, including successes
and failures.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the target partition for the copy operation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON object summarizing the results of the copy operations, including
paths attempted, status of each, and any failure reasons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/copy/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def copy_items(partition):
    &#34;&#34;&#34;Copy items from the given paths to the specified partition and path.

        This function attempts to copy files and directories specified in the &#39;paths&#39;
        JSON array from the request body to the target partition and path with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition. It returns a summary of the copy operations, including successes
        and failures.

        Args:
            partition: A string indicating the target partition for the copy operation.

        Returns:
            A JSON object summarizing the results of the copy operations, including
            paths attempted, status of each, and any failure reasons.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;

    paths = request.json.get(&#39;paths&#39;, [])
    results = []

    for src_path in paths:
        try:
            filename = os.path.basename(src_path)
            dest_path = os.path.join(base_path, filename)
            if os.path.exists(dest_path):
                results.append({&#34;src_path&#34;: src_path, &#34;dest_path&#34;: dest_path, &#34;status&#34;: &#34;Failed&#34;,
                                &#34;reason&#34;: &#34;Destination file already exists&#34;})
                continue
            if os.path.isdir(src_path):
                shutil.copytree(src_path, dest_path)
            elif os.path.isfile(src_path):
                shutil.copy(src_path, dest_path)
            else:
                results.append(
                    {&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Source is not a valid file or directory&#34;})
                continue
            results.append({&#34;src_path&#34;: src_path, &#34;dest_path&#34;: dest_path, &#34;status&#34;: &#34;Success&#34;})
        except PermissionError:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: str(e)})
    return jsonify({&#34;message&#34;: &#34;Copy operation completed&#34;, &#34;results&#34;: results})</code></pre>
</details>
</dd>
<dt id="main.create_file"><code class="name flex">
<span>def <span class="ident">create_file</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a file in the specified partition and path.</p>
<p>This function creates a file in the given partition with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it defaults
to the root of the specified partition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the partition on which to create the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the file was created. On failure, returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/file/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def create_file(partition):
    &#34;&#34;&#34;Create a file in the specified partition and path.

        This function creates a file in the given partition with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition.

        Args:
            partition: A string indicating the partition on which to create the file.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file was created. On failure, returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    file_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;

    if not path or not isinstance(path, str):
        return jsonify({&#39;error&#39;: &#39;Invalid path provided&#39;}), 400

    if os.path.isfile(file_path):
        return jsonify({&#39;error&#39;: &#39;The file already exists&#39;})
    try:
        with open(file_path, &#39;x&#39;) as file:
            pass
        return jsonify({&#39;message&#39;: f&#39;File created at {file_path}&#39;}), 201
    except PermissionError:
        return jsonify({&#39;error&#39;: &#39;Permission denied&#39;}), 403
    except FileNotFoundError:
        return jsonify({&#39;error&#39;: &#39;Invalid partition or path&#39;}), 400
    except OSError as oe:
        return jsonify({&#39;error&#39;: f&#34;OS error: {str(oe)}&#34;}), 400
    except Exception as e:
        return jsonify({&#39;error&#39;: str(e)}), 500</code></pre>
</details>
</dd>
<dt id="main.create_folder"><code class="name flex">
<span>def <span class="ident">create_folder</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a folder in the specified partition and path.</p>
<p>This function creates a folder in the given partition with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it defaults
to the root of the specified partition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the partition on which to create the folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the folder was created. On failure, returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/folder/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def create_folder(partition):
    &#34;&#34;&#34;
    Create a folder in the specified partition and path.

    This function creates a folder in the given partition with the path provided
    via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
    to the root of the specified partition.

    Args:
        partition: A string indicating the partition on which to create the folder.

    Returns:
        A JSON response indicating success or failure. On success, returns a message
        indicating the folder was created. On failure, returns an error message with details.
    &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    folder_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    if not path or not isinstance(path, str):
        return jsonify({&#39;error&#39;: &#39;Invalid path provided&#39;}), 400

    if os.path.isdir(folder_path):
        return jsonify({&#39;error&#39;: &#39;The folder already exists&#39;})

    try:
        os.mkdir(folder_path)
        return jsonify({&#39;message&#39;: &#39;Folder created successfully&#39;})
    except PermissionError:
        return jsonify({&#39;error&#39;: &#39;Permission denied&#39;}), 403
    except FileNotFoundError:
        return jsonify({&#39;error&#39;: &#39;Invalid partition or path&#39;}), 400
    except OSError as oe:
        return jsonify({&#39;error&#39;: f&#34;OS error: {str(oe)}&#34;}), 400
    except Exception as e:  # Catch any other unexpected errors
        return jsonify({&#34;error&#34;: f&#34;Unexpected error occurred: {e}&#34;}), 500</code></pre>
</details>
</dd>
<dt id="main.delete_items"><code class="name flex">
<span>def <span class="ident">delete_items</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete files and directories from the specified paths.</p>
<p>This function attempts to delete files and directories specified in the 'paths' JSON array from the request
body.</p>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the file or the files were deleted. On failure, returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/&#39;, methods=[&#39;DELETE&#39;])
def delete_items():
    &#34;&#34;&#34;
        Delete files and directories from the specified paths.

        This function attempts to delete files and directories specified in the &#39;paths&#39; JSON array from the request
        body.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file or the files were deleted. On failure, returns an error message with details.
        &#34;&#34;&#34;
    paths = request.json.get(&#39;paths&#39;, [])
    results = []
    for path in paths:
        try:
            if not os.path.exists(path):
                results.append({&#34;path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;Path {path} does not exist&#34;})
                continue
            shutil.rmtree(path) if os.path.isdir(path) else os.remove(path)
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Success&#34;})
        except PermissionError:
            results.append({&#34;path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({&#34;src_path&#34;: path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;Could not delete element {path}: {e}&#34;})
    return jsonify({&#34;message&#34;: &#34;All elements have been successfully deleted&#34;, &#34;results&#34;: results})</code></pre>
</details>
</dd>
<dt id="main.edit_textfile"><code class="name flex">
<span>def <span class="ident">edit_textfile</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit a text file from the specified partition and path.</p>
<p>This function edits a file from the specified partition and path with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it returns an error message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the partition on which to edit the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the file was edited. On failure, returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/textfile/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def edit_textfile(partition):
    &#34;&#34;&#34;Edit a text file from the specified partition and path.

    This function edits a file from the specified partition and path with the path provided
    via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it returns an error message.

    Args:
        partition: A string indicating the partition on which to edit the file.

    Returns:
        A JSON response indicating success or failure. On success, returns a message
        indicating the file was edited. On failure, returns an error message with details.
    &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    data = request.json
    text = data.get(&#39;text&#39;, None)
    if not path:
        return jsonify({&#34;error&#34;: &#34;Path is required&#34;}), 400
    base_path = f&#34;{partition}://{path}&#34;
    try:
        if not os.path.isfile(base_path):
            return jsonify({&#34;error&#34;: &#34;File does not exist or is not a file&#34;}), 404
        with open(base_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
            content = f.write(text)
        return jsonify({&#34;message&#34;: f&#34;Successfully edited {path}&#34;})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except IOError as e:
        return jsonify({&#34;error&#34;: f&#34;Could not edit file: {e}&#34;}), 500
    except UnicodeEncodeError as e:
        return jsonify({&#34;error&#34;: f&#34;Encoding error with provided text: {e}&#34;}), 400
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500</code></pre>
</details>
</dd>
<dt id="main.file_manager"><code class="name flex">
<span>def <span class="ident">file_manager</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>The function is used to generate output from a template file based on the Jinja2 engine that is found in the
application's templates folder</p>
<h2 id="returns">Returns</h2>
<p>An HTML template as a response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/&#39;)
def file_manager():
    &#34;&#34;&#34;
    The function is used to generate output from a template file based on the Jinja2 engine that is found in the
    application&#39;s templates folder
    Returns:
        An HTML template as a response
    &#34;&#34;&#34;
    return render_template(&#39;file_manager.html&#39;)</code></pre>
</details>
</dd>
<dt id="main.get_partition"><code class="name flex">
<span>def <span class="ident">get_partition</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of disk partitions.</p>
<p>Retrieves the mounted disk partitions using the psutil library and returns them
as a JSON response. Each partition is represented by its device name.</p>
<h2 id="returns">Returns</h2>
<p>A JSON object with a 'partitions' key containing a list of partitions.
On error, returns a JSON object with an 'error' key and status code 500.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/partitions&#39;, methods=[&#39;GET&#39;])
def get_partition():
    &#34;&#34;&#34;
    Get a list of disk partitions.

    Retrieves the mounted disk partitions using the psutil library and returns them
    as a JSON response. Each partition is represented by its device name.

    Returns:
        A JSON object with a &#39;partitions&#39; key containing a list of partitions.
        On error, returns a JSON object with an &#39;error&#39; key and status code 500.
    &#34;&#34;&#34;
    partitions = []
    try:
        for partition in psutil.disk_partitions():
            partitions.append(partition.device[0])
    except Exception as e:
        return jsonify(error=str(e)), 500

    return jsonify({&#39;partitions&#39;: partitions}), 200</code></pre>
</details>
</dd>
<dt id="main.get_textfile"><code class="name flex">
<span>def <span class="ident">get_textfile</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a text file content from the specified partition and path.</p>
<p>This function takes a text file content from the specified partition and path with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it returns an error message.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the partition on which to get the text content.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the file was edited. On failure, returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/textfile/&lt;partition&gt;&#39;, methods=[&#39;GET&#39;])
def get_textfile(partition):
    &#34;&#34;&#34;Get a text file content from the specified partition and path.

        This function takes a text file content from the specified partition and path with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it returns an error message.

        Args:
            partition: A string indicating the partition on which to get the text content.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file was edited. On failure, returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    if not path:
        return jsonify({&#34;error&#34;: &#34;Path is required&#34;}), 400
    base_path = f&#34;{partition}://{path}&#34;
    try:
        if not os.path.isfile(base_path):
            return jsonify({&#34;error&#34;: &#34;File does not exist or is not a file&#34;}), 404
        with open(base_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f:
            content = f.read()
        return jsonify({&#34;text&#34;: content})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except IOError as e:
        return jsonify({&#34;error&#34;: f&#34;Could not read file: {e}&#34;}), 500
    except OSError as oe:
        return jsonify({&#34;error&#34;: f&#34;OS error: {str(oe)}&#34;}), 500
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500</code></pre>
</details>
</dd>
<dt id="main.move_items"><code class="name flex">
<span>def <span class="ident">move_items</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Move items from the given paths to the specified partition and path.</p>
<p>This function attempts to move files and directories specified in the 'paths'
JSON array from the request body to the target partition and path. It returns
a summary of the move operations, including successes and failures.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the target partition for the move operation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON object summarizing the results of the move operations, including
paths attempted, status of each, and any failure reasons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/move/&lt;partition&gt;&#39;, methods=[&#39;POST&#39;])
def move_items(partition):
    &#34;&#34;&#34;Move items from the given paths to the specified partition and path.

        This function attempts to move files and directories specified in the &#39;paths&#39;
        JSON array from the request body to the target partition and path. It returns
        a summary of the move operations, including successes and failures.

        Args:
            partition: A string indicating the target partition for the move operation.

        Returns:
            A JSON object summarizing the results of the move operations, including
            paths attempted, status of each, and any failure reasons.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    paths = request.json.get(&#39;paths&#39;, [])
    results = []
    for src_path in paths:
        try:
            item_name = os.path.basename(src_path)
            dest_path = os.path.join(base_path, item_name)
            if os.path.exists(dest_path):
                results.append({
                    &#34;src_path&#34;: src_path,
                    &#34;dest_path&#34;: dest_path,
                    &#34;status&#34;: &#34;Failed&#34;,
                    &#34;reason&#34;: &#34;Destination file or directory already exists&#34;
                })
                continue
            shutil.move(src_path, dest_path)

            results.append({
                &#34;src_path&#34;: src_path,
                &#34;dest_path&#34;: dest_path,
                &#34;status&#34;: &#34;Success&#34;
            })
        except PermissionError:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: &#34;Permission denied&#34;})
        except OSError as oe:
            results.append({&#34;src_path&#34;: src_path, &#34;status&#34;: &#34;Failed&#34;, &#34;reason&#34;: f&#34;OS error: {str(oe)}&#34;})
        except Exception as e:
            results.append({
                &#34;src_path&#34;: src_path,
                &#34;status&#34;: &#34;Failed&#34;,
                &#34;reason&#34;: str(e)
            })
    return jsonify({
        &#34;message&#34;: &#34;Move operation completed&#34;,
        &#34;results&#34;: results
    })</code></pre>
</details>
</dd>
<dt id="main.rename_data"><code class="name flex">
<span>def <span class="ident">rename_data</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename a file or a folder from the specified source name with the specified destination name.</p>
<p>This function renames a file or a folder name from the specified source with the destination name,
both source name and destination name are taken from the request body.</p>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns a message
indicating the file or folder was renamed with the provided name. On failure,
returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/rename&#39;, methods=[&#39;POST&#39;])
def rename_data():
    &#34;&#34;&#34;Rename a file or a folder from the specified source name with the specified destination name.

        This function renames a file or a folder name from the specified source with the destination name,
        both source name and destination name are taken from the request body.

        Returns:
            A JSON response indicating success or failure. On success, returns a message
            indicating the file or folder was renamed with the provided name. On failure,
            returns an error message with details.
        &#34;&#34;&#34;
    data = request.json
    source = data.get(&#39;src&#39;, None)
    destination = data.get(&#39;dest&#39;, None)
    if not source or not destination:
        return jsonify({&#34;error&#34;: &#34;Source and destination must be provided&#34;}), 400
    try:
        if not os.path.exists(source):
            return jsonify({&#34;error&#34;: &#34;Source file or directory does not exist&#34;}), 404
        if os.path.exists(destination):
            return jsonify({&#34;error&#34;: &#34;Destination file or directory already exists&#34;}), 400
        os.rename(source, destination)
        return jsonify({&#34;message&#34;: f&#34;Successfully renamed {source} to {destination}&#34;})
    except PermissionError:
        return jsonify({&#34;error&#34;: &#39;Permission denied&#39;}), 403
    except OSError as oe:
        return jsonify({&#34;error&#34;: f&#34;OS error: {str(oe)}&#34;}), 500
    except Exception as e:
        return jsonify({&#34;error&#34;: str(e)}), 500</code></pre>
</details>
</dd>
<dt id="main.show_partition"><code class="name flex">
<span>def <span class="ident">show_partition</span></span>(<span>partition)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the files and directories structure from the specified partition and path.</p>
<p>This function returns the files and directories structure in the given partition with the path provided
via 'path' argument in the request. If the 'path' argument is not provided, it defaults
to the root of the specified partition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>partition</code></strong></dt>
<dd>A string indicating the partition on which to create the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A JSON response indicating success or failure. On success, returns the files from the specified partition
and path along some properties like path, extension, size, the date when the file was created. On failure,
returns an error message with details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/&lt;partition&gt;&#39;, methods=[&#39;GET&#39;])
def show_partition(partition):
    &#34;&#34;&#34;Returns the files and directories structure from the specified partition and path.

        This function returns the files and directories structure in the given partition with the path provided
        via &#39;path&#39; argument in the request. If the &#39;path&#39; argument is not provided, it defaults
        to the root of the specified partition.

        Args:
            partition: A string indicating the partition on which to create the file.

        Returns:
            A JSON response indicating success or failure. On success, returns the files from the specified partition
            and path along some properties like path, extension, size, the date when the file was created. On failure,
            returns an error message with details.
        &#34;&#34;&#34;
    path = request.args.get(&#39;path&#39;, None)
    base_path = f&#34;{partition}://{path}&#34; if path else f&#34;{partition}://&#34;
    files = {}
    exclusions = {&#39;$RECYCLE.BIN&#39;, &#39;$Recycle.Bin&#39;, &#39;.GamingRoot&#39;, &#39;System Volume Information&#39;}

    try:
        for name in os.listdir(base_path):
            if name in exclusions:
                continue
            path = os.path.join(base_path, name)
            file_stats = os.stat(path)
            extension = os.path.splitext(name)[1]
            size = 0 if os.path.isdir(path) else file_stats.st_size
            date = datetime.datetime.fromtimestamp(file_stats.st_ctime).strftime(&#39;%Y-%m-%d %H:%M&#39;)
            files[name] = {&#39;path&#39;: path, &#39;extension&#39;: extension, &#39;size&#39;: size, &#39;date&#39;: date}
    except Exception as e:
        return jsonify({&#34;error&#34;: f&#34;Could not access partition {partition}: {e}&#34;}), 500

    return jsonify({&#34;folders&#34;: files}), 200</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="main.copy_items" href="#main.copy_items">copy_items</a></code></li>
<li><code><a title="main.create_file" href="#main.create_file">create_file</a></code></li>
<li><code><a title="main.create_folder" href="#main.create_folder">create_folder</a></code></li>
<li><code><a title="main.delete_items" href="#main.delete_items">delete_items</a></code></li>
<li><code><a title="main.edit_textfile" href="#main.edit_textfile">edit_textfile</a></code></li>
<li><code><a title="main.file_manager" href="#main.file_manager">file_manager</a></code></li>
<li><code><a title="main.get_partition" href="#main.get_partition">get_partition</a></code></li>
<li><code><a title="main.get_textfile" href="#main.get_textfile">get_textfile</a></code></li>
<li><code><a title="main.move_items" href="#main.move_items">move_items</a></code></li>
<li><code><a title="main.rename_data" href="#main.rename_data">rename_data</a></code></li>
<li><code><a title="main.show_partition" href="#main.show_partition">show_partition</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>